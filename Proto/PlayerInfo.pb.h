// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PlayerInfo.proto

#ifndef PROTOBUF_INCLUDED_PlayerInfo_2eproto
#define PROTOBUF_INCLUDED_PlayerInfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PlayerInfo_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_PlayerInfo_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_PlayerInfo_2eproto();
namespace Proto {
namespace Unity {
class Authentication;
class AuthenticationDefaultTypeInternal;
extern AuthenticationDefaultTypeInternal _Authentication_default_instance_;
class Chat;
class ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class ItemAdd;
class ItemAddDefaultTypeInternal;
extern ItemAddDefaultTypeInternal _ItemAdd_default_instance_;
class ItemDel;
class ItemDelDefaultTypeInternal;
extern ItemDelDefaultTypeInternal _ItemDel_default_instance_;
class ItemEquip;
class ItemEquipDefaultTypeInternal;
extern ItemEquipDefaultTypeInternal _ItemEquip_default_instance_;
class ItemEvent;
class ItemEventDefaultTypeInternal;
extern ItemEventDefaultTypeInternal _ItemEvent_default_instance_;
class ItemInfo;
class ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class ItemTrade;
class ItemTradeDefaultTypeInternal;
extern ItemTradeDefaultTypeInternal _ItemTrade_default_instance_;
class ItemUnEquip;
class ItemUnEquipDefaultTypeInternal;
extern ItemUnEquipDefaultTypeInternal _ItemUnEquip_default_instance_;
class ItemUpdate;
class ItemUpdateDefaultTypeInternal;
extern ItemUpdateDefaultTypeInternal _ItemUpdate_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class PlayerAllFuckInfo;
class PlayerAllFuckInfoDefaultTypeInternal;
extern PlayerAllFuckInfoDefaultTypeInternal _PlayerAllFuckInfo_default_instance_;
class PlayerBag;
class PlayerBagDefaultTypeInternal;
extern PlayerBagDefaultTypeInternal _PlayerBag_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
}  // namespace Unity
}  // namespace Proto
namespace google {
namespace protobuf {
template<> ::Proto::Unity::Authentication* Arena::CreateMaybeMessage<::Proto::Unity::Authentication>(Arena*);
template<> ::Proto::Unity::Chat* Arena::CreateMaybeMessage<::Proto::Unity::Chat>(Arena*);
template<> ::Proto::Unity::ItemAdd* Arena::CreateMaybeMessage<::Proto::Unity::ItemAdd>(Arena*);
template<> ::Proto::Unity::ItemDel* Arena::CreateMaybeMessage<::Proto::Unity::ItemDel>(Arena*);
template<> ::Proto::Unity::ItemEquip* Arena::CreateMaybeMessage<::Proto::Unity::ItemEquip>(Arena*);
template<> ::Proto::Unity::ItemEvent* Arena::CreateMaybeMessage<::Proto::Unity::ItemEvent>(Arena*);
template<> ::Proto::Unity::ItemInfo* Arena::CreateMaybeMessage<::Proto::Unity::ItemInfo>(Arena*);
template<> ::Proto::Unity::ItemTrade* Arena::CreateMaybeMessage<::Proto::Unity::ItemTrade>(Arena*);
template<> ::Proto::Unity::ItemUnEquip* Arena::CreateMaybeMessage<::Proto::Unity::ItemUnEquip>(Arena*);
template<> ::Proto::Unity::ItemUpdate* Arena::CreateMaybeMessage<::Proto::Unity::ItemUpdate>(Arena*);
template<> ::Proto::Unity::Operation* Arena::CreateMaybeMessage<::Proto::Unity::Operation>(Arena*);
template<> ::Proto::Unity::PlayerAllFuckInfo* Arena::CreateMaybeMessage<::Proto::Unity::PlayerAllFuckInfo>(Arena*);
template<> ::Proto::Unity::PlayerBag* Arena::CreateMaybeMessage<::Proto::Unity::PlayerBag>(Arena*);
template<> ::Proto::Unity::PlayerInfo* Arena::CreateMaybeMessage<::Proto::Unity::PlayerInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Proto {
namespace Unity {

// ===================================================================

class PlayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Proto.Unity.Operation op = 9;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 9;
  const ::Proto::Unity::Operation& op() const;
  ::Proto::Unity::Operation* release_op();
  ::Proto::Unity::Operation* mutable_op();
  void set_allocated_op(::Proto::Unity::Operation* op);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // float posX = 3;
  void clear_posx();
  static const int kPosXFieldNumber = 3;
  float posx() const;
  void set_posx(float value);

  // float posZ = 4;
  void clear_posz();
  static const int kPosZFieldNumber = 4;
  float posz() const;
  void set_posz(float value);

  // float angle = 5;
  void clear_angle();
  static const int kAngleFieldNumber = 5;
  float angle() const;
  void set_angle(float value);

  // uint32 Hp = 6;
  void clear_hp();
  static const int kHpFieldNumber = 6;
  ::google::protobuf::uint32 hp() const;
  void set_hp(::google::protobuf::uint32 value);

  // uint32 state = 7;
  void clear_state();
  static const int kStateFieldNumber = 7;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // float speed = 8;
  void clear_speed();
  static const int kSpeedFieldNumber = 8;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.PlayerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Proto::Unity::Operation* op_;
  ::google::protobuf::uint32 id_;
  float posx_;
  float posz_;
  float angle_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 state_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Operation* other);
  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const final {
    return CreateMaybeMessage<Operation>(nullptr);
  }

  Operation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float h = 1;
  void clear_h();
  static const int kHFieldNumber = 1;
  float h() const;
  void set_h(float value);

  // float v = 2;
  void clear_v();
  static const int kVFieldNumber = 2;
  float v() const;
  void set_v(float value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.Operation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float h_;
  float v_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class Chat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.Chat) */ {
 public:
  Chat();
  virtual ~Chat();

  Chat(const Chat& from);

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(Chat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Chat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Chat* other);
  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chat* New() const final {
    return CreateMaybeMessage<Chat>(nullptr);
  }

  Chat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chat& from);
  void MergeFrom(const Chat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 3;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // uint32 ids = 1;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  ::google::protobuf::uint32 ids() const;
  void set_ids(::google::protobuf::uint32 value);

  // uint32 idt = 2;
  void clear_idt();
  static const int kIdtFieldNumber = 2;
  ::google::protobuf::uint32 idt() const;
  void set_idt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.Chat)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::uint32 ids_;
  ::google::protobuf::uint32 idt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class Authentication final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.Authentication) */ {
 public:
  Authentication();
  virtual ~Authentication();

  Authentication(const Authentication& from);

  inline Authentication& operator=(const Authentication& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authentication(Authentication&& from) noexcept
    : Authentication() {
    *this = ::std::move(from);
  }

  inline Authentication& operator=(Authentication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Authentication& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authentication* internal_default_instance() {
    return reinterpret_cast<const Authentication*>(
               &_Authentication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Authentication* other);
  friend void swap(Authentication& a, Authentication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authentication* New() const final {
    return CreateMaybeMessage<Authentication>(nullptr);
  }

  Authentication* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authentication>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authentication& from);
  void MergeFrom(const Authentication& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authentication* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Proto.Unity.Authentication)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemInfo) */ {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ItemInfo* other);
  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemInfo* New() const final {
    return CreateMaybeMessage<ItemInfo>(nullptr);
  }

  ItemInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 m_uid = 1;
  void clear_m_uid();
  static const int kMUidFieldNumber = 1;
  ::google::protobuf::uint32 m_uid() const;
  void set_m_uid(::google::protobuf::uint32 value);

  // uint32 m_type = 2;
  void clear_m_type();
  static const int kMTypeFieldNumber = 2;
  ::google::protobuf::uint32 m_type() const;
  void set_m_type(::google::protobuf::uint32 value);

  // uint32 m_hp = 3;
  void clear_m_hp();
  static const int kMHpFieldNumber = 3;
  ::google::protobuf::uint32 m_hp() const;
  void set_m_hp(::google::protobuf::uint32 value);

  // uint32 m_mp = 4;
  void clear_m_mp();
  static const int kMMpFieldNumber = 4;
  ::google::protobuf::uint32 m_mp() const;
  void set_m_mp(::google::protobuf::uint32 value);

  // uint32 m_atk = 5;
  void clear_m_atk();
  static const int kMAtkFieldNumber = 5;
  ::google::protobuf::uint32 m_atk() const;
  void set_m_atk(::google::protobuf::uint32 value);

  // uint32 m_price = 6;
  void clear_m_price();
  static const int kMPriceFieldNumber = 6;
  ::google::protobuf::uint32 m_price() const;
  void set_m_price(::google::protobuf::uint32 value);

  // uint32 m_count = 7;
  void clear_m_count();
  static const int kMCountFieldNumber = 7;
  ::google::protobuf::uint32 m_count() const;
  void set_m_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 m_uid_;
  ::google::protobuf::uint32 m_type_;
  ::google::protobuf::uint32 m_hp_;
  ::google::protobuf::uint32 m_mp_;
  ::google::protobuf::uint32 m_atk_;
  ::google::protobuf::uint32 m_price_;
  ::google::protobuf::uint32 m_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemEvent) */ {
 public:
  ItemEvent();
  virtual ~ItemEvent();

  ItemEvent(const ItemEvent& from);

  inline ItemEvent& operator=(const ItemEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemEvent(ItemEvent&& from) noexcept
    : ItemEvent() {
    *this = ::std::move(from);
  }

  inline ItemEvent& operator=(ItemEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemEvent* internal_default_instance() {
    return reinterpret_cast<const ItemEvent*>(
               &_ItemEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ItemEvent* other);
  friend void swap(ItemEvent& a, ItemEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemEvent* New() const final {
    return CreateMaybeMessage<ItemEvent>(nullptr);
  }

  ItemEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemEvent& from);
  void MergeFrom(const ItemEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string add1 = 5;
  void clear_add1();
  static const int kAdd1FieldNumber = 5;
  const ::std::string& add1() const;
  void set_add1(const ::std::string& value);
  #if LANG_CXX11
  void set_add1(::std::string&& value);
  #endif
  void set_add1(const char* value);
  void set_add1(const char* value, size_t size);
  ::std::string* mutable_add1();
  ::std::string* release_add1();
  void set_allocated_add1(::std::string* add1);

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // uint32 tid = 4;
  void clear_tid();
  static const int kTidFieldNumber = 4;
  ::google::protobuf::uint32 tid() const;
  void set_tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr add1_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemAdd final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemAdd) */ {
 public:
  ItemAdd();
  virtual ~ItemAdd();

  ItemAdd(const ItemAdd& from);

  inline ItemAdd& operator=(const ItemAdd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemAdd(ItemAdd&& from) noexcept
    : ItemAdd() {
    *this = ::std::move(from);
  }

  inline ItemAdd& operator=(ItemAdd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemAdd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemAdd* internal_default_instance() {
    return reinterpret_cast<const ItemAdd*>(
               &_ItemAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ItemAdd* other);
  friend void swap(ItemAdd& a, ItemAdd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemAdd* New() const final {
    return CreateMaybeMessage<ItemAdd>(nullptr);
  }

  ItemAdd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemAdd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemAdd& from);
  void MergeFrom(const ItemAdd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemAdd)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemDel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemDel) */ {
 public:
  ItemDel();
  virtual ~ItemDel();

  ItemDel(const ItemDel& from);

  inline ItemDel& operator=(const ItemDel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemDel(ItemDel&& from) noexcept
    : ItemDel() {
    *this = ::std::move(from);
  }

  inline ItemDel& operator=(ItemDel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemDel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemDel* internal_default_instance() {
    return reinterpret_cast<const ItemDel*>(
               &_ItemDel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ItemDel* other);
  friend void swap(ItemDel& a, ItemDel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemDel* New() const final {
    return CreateMaybeMessage<ItemDel>(nullptr);
  }

  ItemDel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemDel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemDel& from);
  void MergeFrom(const ItemDel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemDel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemDel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemTrade final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemTrade) */ {
 public:
  ItemTrade();
  virtual ~ItemTrade();

  ItemTrade(const ItemTrade& from);

  inline ItemTrade& operator=(const ItemTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemTrade(ItemTrade&& from) noexcept
    : ItemTrade() {
    *this = ::std::move(from);
  }

  inline ItemTrade& operator=(ItemTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemTrade* internal_default_instance() {
    return reinterpret_cast<const ItemTrade*>(
               &_ItemTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ItemTrade* other);
  friend void swap(ItemTrade& a, ItemTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemTrade* New() const final {
    return CreateMaybeMessage<ItemTrade>(nullptr);
  }

  ItemTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemTrade& from);
  void MergeFrom(const ItemTrade& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // uint32 tid = 4;
  void clear_tid();
  static const int kTidFieldNumber = 4;
  ::google::protobuf::uint32 tid() const;
  void set_tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemTrade)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemEquip final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemEquip) */ {
 public:
  ItemEquip();
  virtual ~ItemEquip();

  ItemEquip(const ItemEquip& from);

  inline ItemEquip& operator=(const ItemEquip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemEquip(ItemEquip&& from) noexcept
    : ItemEquip() {
    *this = ::std::move(from);
  }

  inline ItemEquip& operator=(ItemEquip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemEquip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemEquip* internal_default_instance() {
    return reinterpret_cast<const ItemEquip*>(
               &_ItemEquip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ItemEquip* other);
  friend void swap(ItemEquip& a, ItemEquip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemEquip* New() const final {
    return CreateMaybeMessage<ItemEquip>(nullptr);
  }

  ItemEquip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemEquip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemEquip& from);
  void MergeFrom(const ItemEquip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEquip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemEquip)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemUnEquip final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemUnEquip) */ {
 public:
  ItemUnEquip();
  virtual ~ItemUnEquip();

  ItemUnEquip(const ItemUnEquip& from);

  inline ItemUnEquip& operator=(const ItemUnEquip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemUnEquip(ItemUnEquip&& from) noexcept
    : ItemUnEquip() {
    *this = ::std::move(from);
  }

  inline ItemUnEquip& operator=(ItemUnEquip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemUnEquip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemUnEquip* internal_default_instance() {
    return reinterpret_cast<const ItemUnEquip*>(
               &_ItemUnEquip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ItemUnEquip* other);
  friend void swap(ItemUnEquip& a, ItemUnEquip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemUnEquip* New() const final {
    return CreateMaybeMessage<ItemUnEquip>(nullptr);
  }

  ItemUnEquip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemUnEquip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemUnEquip& from);
  void MergeFrom(const ItemUnEquip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemUnEquip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 optype = 1;
  void clear_optype();
  static const int kOptypeFieldNumber = 1;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // uint32 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemUnEquip)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class ItemUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.ItemUpdate) */ {
 public:
  ItemUpdate();
  virtual ~ItemUpdate();

  ItemUpdate(const ItemUpdate& from);

  inline ItemUpdate& operator=(const ItemUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemUpdate(ItemUpdate&& from) noexcept
    : ItemUpdate() {
    *this = ::std::move(from);
  }

  inline ItemUpdate& operator=(ItemUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ItemUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemUpdate* internal_default_instance() {
    return reinterpret_cast<const ItemUpdate*>(
               &_ItemUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ItemUpdate* other);
  friend void swap(ItemUpdate& a, ItemUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemUpdate* New() const final {
    return CreateMaybeMessage<ItemUpdate>(nullptr);
  }

  ItemUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemUpdate& from);
  void MergeFrom(const ItemUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Proto.Unity.ItemInfo m_item = 2;
  bool has_m_item() const;
  void clear_m_item();
  static const int kMItemFieldNumber = 2;
  const ::Proto::Unity::ItemInfo& m_item() const;
  ::Proto::Unity::ItemInfo* release_m_item();
  ::Proto::Unity::ItemInfo* mutable_m_item();
  void set_allocated_m_item(::Proto::Unity::ItemInfo* m_item);

  // uint32 m_optype = 1;
  void clear_m_optype();
  static const int kMOptypeFieldNumber = 1;
  ::google::protobuf::uint32 m_optype() const;
  void set_m_optype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.Unity.ItemUpdate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Unity::ItemInfo* m_item_;
  ::google::protobuf::uint32 m_optype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class PlayerBag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.PlayerBag) */ {
 public:
  PlayerBag();
  virtual ~PlayerBag();

  PlayerBag(const PlayerBag& from);

  inline PlayerBag& operator=(const PlayerBag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerBag(PlayerBag&& from) noexcept
    : PlayerBag() {
    *this = ::std::move(from);
  }

  inline PlayerBag& operator=(PlayerBag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlayerBag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerBag* internal_default_instance() {
    return reinterpret_cast<const PlayerBag*>(
               &_PlayerBag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PlayerBag* other);
  friend void swap(PlayerBag& a, PlayerBag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerBag* New() const final {
    return CreateMaybeMessage<PlayerBag>(nullptr);
  }

  PlayerBag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerBag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerBag& from);
  void MergeFrom(const PlayerBag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.Unity.ItemInfo Items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  ::Proto::Unity::ItemInfo* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::Proto::Unity::ItemInfo >*
      mutable_items();
  const ::Proto::Unity::ItemInfo& items(int index) const;
  ::Proto::Unity::ItemInfo* add_items();
  const ::google::protobuf::RepeatedPtrField< ::Proto::Unity::ItemInfo >&
      items() const;

  // repeated uint32 equiped = 2;
  int equiped_size() const;
  void clear_equiped();
  static const int kEquipedFieldNumber = 2;
  ::google::protobuf::uint32 equiped(int index) const;
  void set_equiped(int index, ::google::protobuf::uint32 value);
  void add_equiped(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      equiped() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_equiped();

  // @@protoc_insertion_point(class_scope:Proto.Unity.PlayerBag)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Unity::ItemInfo > items_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > equiped_;
  mutable std::atomic<int> _equiped_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// -------------------------------------------------------------------

class PlayerAllFuckInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Unity.PlayerAllFuckInfo) */ {
 public:
  PlayerAllFuckInfo();
  virtual ~PlayerAllFuckInfo();

  PlayerAllFuckInfo(const PlayerAllFuckInfo& from);

  inline PlayerAllFuckInfo& operator=(const PlayerAllFuckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerAllFuckInfo(PlayerAllFuckInfo&& from) noexcept
    : PlayerAllFuckInfo() {
    *this = ::std::move(from);
  }

  inline PlayerAllFuckInfo& operator=(PlayerAllFuckInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlayerAllFuckInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerAllFuckInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerAllFuckInfo*>(
               &_PlayerAllFuckInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(PlayerAllFuckInfo* other);
  friend void swap(PlayerAllFuckInfo& a, PlayerAllFuckInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerAllFuckInfo* New() const final {
    return CreateMaybeMessage<PlayerAllFuckInfo>(nullptr);
  }

  PlayerAllFuckInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerAllFuckInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerAllFuckInfo& from);
  void MergeFrom(const PlayerAllFuckInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerAllFuckInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Proto.Unity.PlayerInfo baseinfo = 1;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseinfoFieldNumber = 1;
  const ::Proto::Unity::PlayerInfo& baseinfo() const;
  ::Proto::Unity::PlayerInfo* release_baseinfo();
  ::Proto::Unity::PlayerInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::Proto::Unity::PlayerInfo* baseinfo);

  // .Proto.Unity.PlayerBag baginfo = 2;
  bool has_baginfo() const;
  void clear_baginfo();
  static const int kBaginfoFieldNumber = 2;
  const ::Proto::Unity::PlayerBag& baginfo() const;
  ::Proto::Unity::PlayerBag* release_baginfo();
  ::Proto::Unity::PlayerBag* mutable_baginfo();
  void set_allocated_baginfo(::Proto::Unity::PlayerBag* baginfo);

  // @@protoc_insertion_point(class_scope:Proto.Unity.PlayerAllFuckInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Unity::PlayerInfo* baseinfo_;
  ::Proto::Unity::PlayerBag* baginfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PlayerInfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerInfo

// uint32 id = 1;
inline void PlayerInfo::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.id)
  return id_;
}
inline void PlayerInfo::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.id)
}

// string name = 2;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.name)
  return name_.GetNoArena();
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.name)
}
#if LANG_CXX11
inline void PlayerInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Unity.PlayerInfo.name)
}
#endif
inline void PlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Unity.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Unity.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Unity.PlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:Proto.Unity.PlayerInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.PlayerInfo.name)
}

// float posX = 3;
inline void PlayerInfo::clear_posx() {
  posx_ = 0;
}
inline float PlayerInfo::posx() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.posX)
  return posx_;
}
inline void PlayerInfo::set_posx(float value) {
  
  posx_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.posX)
}

// float posZ = 4;
inline void PlayerInfo::clear_posz() {
  posz_ = 0;
}
inline float PlayerInfo::posz() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.posZ)
  return posz_;
}
inline void PlayerInfo::set_posz(float value) {
  
  posz_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.posZ)
}

// float angle = 5;
inline void PlayerInfo::clear_angle() {
  angle_ = 0;
}
inline float PlayerInfo::angle() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.angle)
  return angle_;
}
inline void PlayerInfo::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.angle)
}

// uint32 Hp = 6;
inline void PlayerInfo::clear_hp() {
  hp_ = 0u;
}
inline ::google::protobuf::uint32 PlayerInfo::hp() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.Hp)
  return hp_;
}
inline void PlayerInfo::set_hp(::google::protobuf::uint32 value) {
  
  hp_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.Hp)
}

// uint32 state = 7;
inline void PlayerInfo::clear_state() {
  state_ = 0u;
}
inline ::google::protobuf::uint32 PlayerInfo::state() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.state)
  return state_;
}
inline void PlayerInfo::set_state(::google::protobuf::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.state)
}

// float speed = 8;
inline void PlayerInfo::clear_speed() {
  speed_ = 0;
}
inline float PlayerInfo::speed() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.speed)
  return speed_;
}
inline void PlayerInfo::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerInfo.speed)
}

// .Proto.Unity.Operation op = 9;
inline bool PlayerInfo::has_op() const {
  return this != internal_default_instance() && op_ != nullptr;
}
inline void PlayerInfo::clear_op() {
  if (GetArenaNoVirtual() == nullptr && op_ != nullptr) {
    delete op_;
  }
  op_ = nullptr;
}
inline const ::Proto::Unity::Operation& PlayerInfo::op() const {
  const ::Proto::Unity::Operation* p = op_;
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerInfo.op)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Unity::Operation*>(
      &::Proto::Unity::_Operation_default_instance_);
}
inline ::Proto::Unity::Operation* PlayerInfo::release_op() {
  // @@protoc_insertion_point(field_release:Proto.Unity.PlayerInfo.op)
  
  ::Proto::Unity::Operation* temp = op_;
  op_ = nullptr;
  return temp;
}
inline ::Proto::Unity::Operation* PlayerInfo::mutable_op() {
  
  if (op_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Unity::Operation>(GetArenaNoVirtual());
    op_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Unity.PlayerInfo.op)
  return op_;
}
inline void PlayerInfo::set_allocated_op(::Proto::Unity::Operation* op) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete op_;
  }
  if (op) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      op = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.PlayerInfo.op)
}

// -------------------------------------------------------------------

// Operation

// float h = 1;
inline void Operation::clear_h() {
  h_ = 0;
}
inline float Operation::h() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Operation.h)
  return h_;
}
inline void Operation::set_h(float value) {
  
  h_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.Operation.h)
}

// float v = 2;
inline void Operation::clear_v() {
  v_ = 0;
}
inline float Operation::v() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Operation.v)
  return v_;
}
inline void Operation::set_v(float value) {
  
  v_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.Operation.v)
}

// -------------------------------------------------------------------

// Chat

// uint32 ids = 1;
inline void Chat::clear_ids() {
  ids_ = 0u;
}
inline ::google::protobuf::uint32 Chat::ids() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Chat.ids)
  return ids_;
}
inline void Chat::set_ids(::google::protobuf::uint32 value) {
  
  ids_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.Chat.ids)
}

// uint32 idt = 2;
inline void Chat::clear_idt() {
  idt_ = 0u;
}
inline ::google::protobuf::uint32 Chat::idt() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Chat.idt)
  return idt_;
}
inline void Chat::set_idt(::google::protobuf::uint32 value) {
  
  idt_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.Chat.idt)
}

// string msg = 3;
inline void Chat::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chat::msg() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Chat.msg)
  return msg_.GetNoArena();
}
inline void Chat::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Unity.Chat.msg)
}
#if LANG_CXX11
inline void Chat::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Unity.Chat.msg)
}
#endif
inline void Chat::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Unity.Chat.msg)
}
inline void Chat::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Unity.Chat.msg)
}
inline ::std::string* Chat::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Unity.Chat.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chat::release_msg() {
  // @@protoc_insertion_point(field_release:Proto.Unity.Chat.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chat::set_allocated_msg(::std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.Chat.msg)
}

// -------------------------------------------------------------------

// Authentication

// string name = 1;
inline void Authentication::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Authentication::name() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Authentication.name)
  return name_.GetNoArena();
}
inline void Authentication::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Unity.Authentication.name)
}
#if LANG_CXX11
inline void Authentication::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Unity.Authentication.name)
}
#endif
inline void Authentication::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Unity.Authentication.name)
}
inline void Authentication::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Unity.Authentication.name)
}
inline ::std::string* Authentication::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Unity.Authentication.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authentication::release_name() {
  // @@protoc_insertion_point(field_release:Proto.Unity.Authentication.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authentication::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.Authentication.name)
}

// string password = 2;
inline void Authentication::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Authentication::password() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.Authentication.password)
  return password_.GetNoArena();
}
inline void Authentication::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Unity.Authentication.password)
}
#if LANG_CXX11
inline void Authentication::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Unity.Authentication.password)
}
#endif
inline void Authentication::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Unity.Authentication.password)
}
inline void Authentication::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Unity.Authentication.password)
}
inline ::std::string* Authentication::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Unity.Authentication.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authentication::release_password() {
  // @@protoc_insertion_point(field_release:Proto.Unity.Authentication.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authentication::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.Authentication.password)
}

// -------------------------------------------------------------------

// ItemInfo

// uint32 m_uid = 1;
inline void ItemInfo::clear_m_uid() {
  m_uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_uid)
  return m_uid_;
}
inline void ItemInfo::set_m_uid(::google::protobuf::uint32 value) {
  
  m_uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_uid)
}

// uint32 m_type = 2;
inline void ItemInfo::clear_m_type() {
  m_type_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_type() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_type)
  return m_type_;
}
inline void ItemInfo::set_m_type(::google::protobuf::uint32 value) {
  
  m_type_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_type)
}

// uint32 m_hp = 3;
inline void ItemInfo::clear_m_hp() {
  m_hp_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_hp() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_hp)
  return m_hp_;
}
inline void ItemInfo::set_m_hp(::google::protobuf::uint32 value) {
  
  m_hp_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_hp)
}

// uint32 m_mp = 4;
inline void ItemInfo::clear_m_mp() {
  m_mp_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_mp() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_mp)
  return m_mp_;
}
inline void ItemInfo::set_m_mp(::google::protobuf::uint32 value) {
  
  m_mp_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_mp)
}

// uint32 m_atk = 5;
inline void ItemInfo::clear_m_atk() {
  m_atk_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_atk() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_atk)
  return m_atk_;
}
inline void ItemInfo::set_m_atk(::google::protobuf::uint32 value) {
  
  m_atk_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_atk)
}

// uint32 m_price = 6;
inline void ItemInfo::clear_m_price() {
  m_price_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_price() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_price)
  return m_price_;
}
inline void ItemInfo::set_m_price(::google::protobuf::uint32 value) {
  
  m_price_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_price)
}

// uint32 m_count = 7;
inline void ItemInfo::clear_m_count() {
  m_count_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::m_count() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemInfo.m_count)
  return m_count_;
}
inline void ItemInfo::set_m_count(::google::protobuf::uint32 value) {
  
  m_count_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemInfo.m_count)
}

// -------------------------------------------------------------------

// ItemEvent

// uint32 optype = 1;
inline void ItemEvent::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemEvent::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEvent.optype)
  return optype_;
}
inline void ItemEvent::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEvent.optype)
}

// uint32 uid = 2;
inline void ItemEvent::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemEvent::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEvent.uid)
  return uid_;
}
inline void ItemEvent::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEvent.uid)
}

// uint32 count = 3;
inline void ItemEvent::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ItemEvent::count() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEvent.count)
  return count_;
}
inline void ItemEvent::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEvent.count)
}

// string add1 = 5;
inline void ItemEvent::clear_add1() {
  add1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ItemEvent::add1() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEvent.add1)
  return add1_.GetNoArena();
}
inline void ItemEvent::set_add1(const ::std::string& value) {
  
  add1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEvent.add1)
}
#if LANG_CXX11
inline void ItemEvent::set_add1(::std::string&& value) {
  
  add1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Unity.ItemEvent.add1)
}
#endif
inline void ItemEvent::set_add1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  add1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Unity.ItemEvent.add1)
}
inline void ItemEvent::set_add1(const char* value, size_t size) {
  
  add1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Unity.ItemEvent.add1)
}
inline ::std::string* ItemEvent::mutable_add1() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Unity.ItemEvent.add1)
  return add1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ItemEvent::release_add1() {
  // @@protoc_insertion_point(field_release:Proto.Unity.ItemEvent.add1)
  
  return add1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ItemEvent::set_allocated_add1(::std::string* add1) {
  if (add1 != nullptr) {
    
  } else {
    
  }
  add1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), add1);
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.ItemEvent.add1)
}

// uint32 tid = 4;
inline void ItemEvent::clear_tid() {
  tid_ = 0u;
}
inline ::google::protobuf::uint32 ItemEvent::tid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEvent.tid)
  return tid_;
}
inline void ItemEvent::set_tid(::google::protobuf::uint32 value) {
  
  tid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEvent.tid)
}

// -------------------------------------------------------------------

// ItemAdd

// uint32 optype = 1;
inline void ItemAdd::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemAdd::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemAdd.optype)
  return optype_;
}
inline void ItemAdd::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemAdd.optype)
}

// uint32 uid = 2;
inline void ItemAdd::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemAdd::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemAdd.uid)
  return uid_;
}
inline void ItemAdd::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemAdd.uid)
}

// uint32 count = 3;
inline void ItemAdd::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ItemAdd::count() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemAdd.count)
  return count_;
}
inline void ItemAdd::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemAdd.count)
}

// -------------------------------------------------------------------

// ItemDel

// uint32 optype = 1;
inline void ItemDel::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemDel::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemDel.optype)
  return optype_;
}
inline void ItemDel::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemDel.optype)
}

// uint32 uid = 2;
inline void ItemDel::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemDel::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemDel.uid)
  return uid_;
}
inline void ItemDel::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemDel.uid)
}

// uint32 count = 3;
inline void ItemDel::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ItemDel::count() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemDel.count)
  return count_;
}
inline void ItemDel::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemDel.count)
}

// -------------------------------------------------------------------

// ItemTrade

// uint32 optype = 1;
inline void ItemTrade::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemTrade::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemTrade.optype)
  return optype_;
}
inline void ItemTrade::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemTrade.optype)
}

// uint32 uid = 2;
inline void ItemTrade::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemTrade::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemTrade.uid)
  return uid_;
}
inline void ItemTrade::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemTrade.uid)
}

// uint32 count = 3;
inline void ItemTrade::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ItemTrade::count() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemTrade.count)
  return count_;
}
inline void ItemTrade::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemTrade.count)
}

// uint32 tid = 4;
inline void ItemTrade::clear_tid() {
  tid_ = 0u;
}
inline ::google::protobuf::uint32 ItemTrade::tid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemTrade.tid)
  return tid_;
}
inline void ItemTrade::set_tid(::google::protobuf::uint32 value) {
  
  tid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemTrade.tid)
}

// -------------------------------------------------------------------

// ItemEquip

// uint32 optype = 1;
inline void ItemEquip::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemEquip::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEquip.optype)
  return optype_;
}
inline void ItemEquip::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEquip.optype)
}

// uint32 uid = 2;
inline void ItemEquip::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemEquip::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemEquip.uid)
  return uid_;
}
inline void ItemEquip::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemEquip.uid)
}

// -------------------------------------------------------------------

// ItemUnEquip

// uint32 optype = 1;
inline void ItemUnEquip::clear_optype() {
  optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemUnEquip::optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemUnEquip.optype)
  return optype_;
}
inline void ItemUnEquip::set_optype(::google::protobuf::uint32 value) {
  
  optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemUnEquip.optype)
}

// uint32 uid = 2;
inline void ItemUnEquip::clear_uid() {
  uid_ = 0u;
}
inline ::google::protobuf::uint32 ItemUnEquip::uid() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemUnEquip.uid)
  return uid_;
}
inline void ItemUnEquip::set_uid(::google::protobuf::uint32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemUnEquip.uid)
}

// -------------------------------------------------------------------

// ItemUpdate

// uint32 m_optype = 1;
inline void ItemUpdate::clear_m_optype() {
  m_optype_ = 0u;
}
inline ::google::protobuf::uint32 ItemUpdate::m_optype() const {
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemUpdate.m_optype)
  return m_optype_;
}
inline void ItemUpdate::set_m_optype(::google::protobuf::uint32 value) {
  
  m_optype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Unity.ItemUpdate.m_optype)
}

// .Proto.Unity.ItemInfo m_item = 2;
inline bool ItemUpdate::has_m_item() const {
  return this != internal_default_instance() && m_item_ != nullptr;
}
inline void ItemUpdate::clear_m_item() {
  if (GetArenaNoVirtual() == nullptr && m_item_ != nullptr) {
    delete m_item_;
  }
  m_item_ = nullptr;
}
inline const ::Proto::Unity::ItemInfo& ItemUpdate::m_item() const {
  const ::Proto::Unity::ItemInfo* p = m_item_;
  // @@protoc_insertion_point(field_get:Proto.Unity.ItemUpdate.m_item)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Unity::ItemInfo*>(
      &::Proto::Unity::_ItemInfo_default_instance_);
}
inline ::Proto::Unity::ItemInfo* ItemUpdate::release_m_item() {
  // @@protoc_insertion_point(field_release:Proto.Unity.ItemUpdate.m_item)
  
  ::Proto::Unity::ItemInfo* temp = m_item_;
  m_item_ = nullptr;
  return temp;
}
inline ::Proto::Unity::ItemInfo* ItemUpdate::mutable_m_item() {
  
  if (m_item_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Unity::ItemInfo>(GetArenaNoVirtual());
    m_item_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Unity.ItemUpdate.m_item)
  return m_item_;
}
inline void ItemUpdate::set_allocated_m_item(::Proto::Unity::ItemInfo* m_item) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_item_;
  }
  if (m_item) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_item = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m_item, submessage_arena);
    }
    
  } else {
    
  }
  m_item_ = m_item;
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.ItemUpdate.m_item)
}

// -------------------------------------------------------------------

// PlayerBag

// repeated .Proto.Unity.ItemInfo Items = 1;
inline int PlayerBag::items_size() const {
  return items_.size();
}
inline void PlayerBag::clear_items() {
  items_.Clear();
}
inline ::Proto::Unity::ItemInfo* PlayerBag::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Unity.PlayerBag.Items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Unity::ItemInfo >*
PlayerBag::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Unity.PlayerBag.Items)
  return &items_;
}
inline const ::Proto::Unity::ItemInfo& PlayerBag::items(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerBag.Items)
  return items_.Get(index);
}
inline ::Proto::Unity::ItemInfo* PlayerBag::add_items() {
  // @@protoc_insertion_point(field_add:Proto.Unity.PlayerBag.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Unity::ItemInfo >&
PlayerBag::items() const {
  // @@protoc_insertion_point(field_list:Proto.Unity.PlayerBag.Items)
  return items_;
}

// repeated uint32 equiped = 2;
inline int PlayerBag::equiped_size() const {
  return equiped_.size();
}
inline void PlayerBag::clear_equiped() {
  equiped_.Clear();
}
inline ::google::protobuf::uint32 PlayerBag::equiped(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerBag.equiped)
  return equiped_.Get(index);
}
inline void PlayerBag::set_equiped(int index, ::google::protobuf::uint32 value) {
  equiped_.Set(index, value);
  // @@protoc_insertion_point(field_set:Proto.Unity.PlayerBag.equiped)
}
inline void PlayerBag::add_equiped(::google::protobuf::uint32 value) {
  equiped_.Add(value);
  // @@protoc_insertion_point(field_add:Proto.Unity.PlayerBag.equiped)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerBag::equiped() const {
  // @@protoc_insertion_point(field_list:Proto.Unity.PlayerBag.equiped)
  return equiped_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerBag::mutable_equiped() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Unity.PlayerBag.equiped)
  return &equiped_;
}

// -------------------------------------------------------------------

// PlayerAllFuckInfo

// .Proto.Unity.PlayerInfo baseinfo = 1;
inline bool PlayerAllFuckInfo::has_baseinfo() const {
  return this != internal_default_instance() && baseinfo_ != nullptr;
}
inline void PlayerAllFuckInfo::clear_baseinfo() {
  if (GetArenaNoVirtual() == nullptr && baseinfo_ != nullptr) {
    delete baseinfo_;
  }
  baseinfo_ = nullptr;
}
inline const ::Proto::Unity::PlayerInfo& PlayerAllFuckInfo::baseinfo() const {
  const ::Proto::Unity::PlayerInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerAllFuckInfo.baseinfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Unity::PlayerInfo*>(
      &::Proto::Unity::_PlayerInfo_default_instance_);
}
inline ::Proto::Unity::PlayerInfo* PlayerAllFuckInfo::release_baseinfo() {
  // @@protoc_insertion_point(field_release:Proto.Unity.PlayerAllFuckInfo.baseinfo)
  
  ::Proto::Unity::PlayerInfo* temp = baseinfo_;
  baseinfo_ = nullptr;
  return temp;
}
inline ::Proto::Unity::PlayerInfo* PlayerAllFuckInfo::mutable_baseinfo() {
  
  if (baseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Unity::PlayerInfo>(GetArenaNoVirtual());
    baseinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Unity.PlayerAllFuckInfo.baseinfo)
  return baseinfo_;
}
inline void PlayerAllFuckInfo::set_allocated_baseinfo(::Proto::Unity::PlayerInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    
  } else {
    
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.PlayerAllFuckInfo.baseinfo)
}

// .Proto.Unity.PlayerBag baginfo = 2;
inline bool PlayerAllFuckInfo::has_baginfo() const {
  return this != internal_default_instance() && baginfo_ != nullptr;
}
inline void PlayerAllFuckInfo::clear_baginfo() {
  if (GetArenaNoVirtual() == nullptr && baginfo_ != nullptr) {
    delete baginfo_;
  }
  baginfo_ = nullptr;
}
inline const ::Proto::Unity::PlayerBag& PlayerAllFuckInfo::baginfo() const {
  const ::Proto::Unity::PlayerBag* p = baginfo_;
  // @@protoc_insertion_point(field_get:Proto.Unity.PlayerAllFuckInfo.baginfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Unity::PlayerBag*>(
      &::Proto::Unity::_PlayerBag_default_instance_);
}
inline ::Proto::Unity::PlayerBag* PlayerAllFuckInfo::release_baginfo() {
  // @@protoc_insertion_point(field_release:Proto.Unity.PlayerAllFuckInfo.baginfo)
  
  ::Proto::Unity::PlayerBag* temp = baginfo_;
  baginfo_ = nullptr;
  return temp;
}
inline ::Proto::Unity::PlayerBag* PlayerAllFuckInfo::mutable_baginfo() {
  
  if (baginfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Unity::PlayerBag>(GetArenaNoVirtual());
    baginfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Unity.PlayerAllFuckInfo.baginfo)
  return baginfo_;
}
inline void PlayerAllFuckInfo::set_allocated_baginfo(::Proto::Unity::PlayerBag* baginfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete baginfo_;
  }
  if (baginfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      baginfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baginfo, submessage_arena);
    }
    
  } else {
    
  }
  baginfo_ = baginfo;
  // @@protoc_insertion_point(field_set_allocated:Proto.Unity.PlayerAllFuckInfo.baginfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Unity
}  // namespace Proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_PlayerInfo_2eproto
